#! /bin/sh
#  -*- Mode: Shell-script -*-
# for.test --- test functionality of switching shells
#
# Time-stamp:        "2005-01-18 17:23:14 bkorb"
# Author:            Bruce Korb <bkorb@gnu.org>
# Maintainer:        Bruce Korb <bkorb@gnu.org>
# Created:           Fri Oct 1 10:27:31 PDT 1999
# Last Modified:     $Date: 2005/01/19 01:49:59 $
#            by: bkorb
#
#  The test will verify that a real shell processes the declarations
#  and our weirdo shell handles the template.
#
# $Id: shell.test,v 4.2 2005/01/19 01:49:59 bkorb Exp $
# ----------------------------------------------------------------------

exec 9>&2

# Common definitions
if test -z "$srcdir"; then
    srcdir=`dirname $0`
    test "${VERBOSE+set}" != set && VERBOSE=1
fi
. $srcdir/defs

# # # # # # # # # # TEMPLATE FILE # # # # # # # # #

cat > ${testname}.c <<'_EOF_'
#include <stdio.h>
#include <string.h>
#include <ctype.h>
char buf[ 4096 ];
int
main( int argc, char** argv )
{
  for (;;) {
    char* pz = fgets(buf, sizeof(buf),stdin);
    if (pz == NULL)
      break;
    while (isspace(*pz)) pz++;
    if (strncmp( pz, "cd ", 3 ) == 0) /* drop the cd commands */
      continue;
    if ((strncmp( pz, "echo", 4 ) == 0) && isspace( pz[4] )) {
      pz += 5;
      while (isspace(*pz)) pz++;  /* suppress the 'echo' */
    }
    if (*pz == '\0') pz--;  /* always force a newline */
    fputs( pz, stdout );
    fflush( stdout );
  }
  return 0;
}
_EOF_
$CC -o ${testname} ${testname}.c

#  The backslashes are stripped by the here-doc processing
#
echo creating ${testname}.tpl
cat > ${testname}.tpl <<_EOF_
<= AutoGen5 template test
   (setenv "SHELL" "./${testname}") =>
<=\` echo SHELL=\$SHELL \`=>
Some <=dummy=> text
<= FOR foo =>
foo[<=(for-index)=>]       = <=foo=>
raw-shell-str: <=(raw-shell-str (get "foo"))=>
shell-str:     <=(shell-str (get "foo"))=>
sub-shell-str: <=(sub-shell-str (get "foo"))=>
<= ENDFOR =>
<=\`   : This is a final test \`=>
_EOF_

echo creating ${testname}.def
cat >${testname}.def <<'EOF'
AutoGen Definitions shell.tpl;

foo = "''foo'' 'foo' \"foo\" `foo` $foo";
foo = '\\\'bar\\\' \\"bar\\" \`bar\` \$bar';
foo = '\\\\\'BAZ\\\\\' \\\\"BAZ\\\\" \\\`BAZ\\\` \\\$BAZ';
EOF
echo 'dummy = `echo "mumble"`;' >> ${testname}.def

# this is the output we should expect to see
cat > ${testname}.sample <<'_EOF_'
SHELL=$SHELL
Some mumble text

foo[0]       = ''foo'' 'foo' "foo" `foo` $foo
raw-shell-str: \'\''foo'\'\'' '\''foo'\'' "foo" `foo` $foo'
shell-str:     "''foo'' 'foo' \"foo\" `foo` $foo"
sub-shell-str: `''foo'' 'foo' "foo" \`foo\` $foo`

foo[1]       = \'bar\' \"bar\" \`bar\` \$bar
raw-shell-str: '\'\''bar\'\'' \"bar\" \`bar\` \$bar'
shell-str:     "\\'bar\\' \\\"bar\\\" \`bar\` \$bar"
sub-shell-str: `\\'bar\\' \"bar\" \\\`bar\\\` \$bar`

foo[2]       = \\'BAZ\\' \\"BAZ\\" \\`BAZ\\` \\$BAZ
raw-shell-str: '\\'\''BAZ\\'\'' \\"BAZ\\" \\`BAZ\\` \\$BAZ'
shell-str:     "\\\\'BAZ\\\\' \\\\\"BAZ\\\\\" \\\`BAZ\\\` \\\$BAZ"
sub-shell-str: `\\\\'BAZ\\\\' \\\"BAZ\\\" \\\\\`BAZ\\\\\` \\\$BAZ`

: This is a final test
_EOF_

${AGexe} ${testname}.def || failure "${AGexe} ${testname}.def"
if cmp -s ${testname}.test ${testname}.sample
then cleanup
     exit 0
fi

if fgrep 'SHELL=' ${testname}.test > /dev/null 2>&1
then
  if fgrep 'SHELL=$SHELL' ${testname}.test > /dev/null 2>&1
  then : ; else
    cat >&9 <<- _EOF_
	The ${testname}.test output file does not start with "SHELL=\$SHELL"
	This is because you have a Guile library that cannot modify
	the environment.  This is a known breakage on some platforms
	(viz., BSD derivatives).  Sorry.
	_EOF_
    cleanup
    exit 0
  fi
fi

failure "`set +x;diff -c ${testname}.sample ${testname}.test`"

# end of for.test
