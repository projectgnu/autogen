
autogen definitions options;

/*
 *   $Id: opts.def,v 3.5 2002/12/19 01:35:37 bkorb Exp $
 */

/*
 *  AutoGen copyright 1992-1999 Bruce Korb
 *
 *  AutoGen is free software.
 *  You may redistribute it and/or modify it under the terms of the
 *  GNU General Public License, as published by the Free Software
 *  Foundation; either version 2, or (at your option) any later version.
 *
 *  AutoGen is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with AutoGen.  See the file "COPYING".  If not,
 *  write to:  The Free Software Foundation, Inc.,
 *             59 Temple Place - Suite 330,
 *             Boston,  MA  02111-1307, USA.
 */

copyright = {
    date   = "1999-2001";
    type   = gpl;
    owner  = "Bruce Korb";
    eaddr  = "autogen-bugs@lists.sf.net";
};

prog_name     = "getdefs";
prog_title    = "AutoGen Definition Extraction Tool";

version       = "1.3";
homerc        = /dev/null;

flag = {
    name      = "defs_to_get";
    arg_type  = string;
    arg_name  = reg-ex;
    descrip   = 'Regexp to look for after the "/*="';
    doc =
    "If you want definitions only from a particular category, or even\n"
    "with names matching particular patterns, then specify this regular\n"
    "expression for the text that must follow the @code{/*=}.";
};

flag = {
    name        = ordering;
    arg_type    = string;
    arg_optional;
    arg_name    = file-name;
    disable     = no;
    enabled;
    descrip     = "Alphabetize or use named file";
    doc = <<-  _EOF_
	By default, ordering is alphabetical by the entry name.  Use,
	@code{no-ordering} if order is unimportant.  Use @code{ordering}
	with no argument to order without case sensitivity.  Use
	@code{ordering=<file-name>} if chronological order is important.
	getdefs will maintain the text content of @code{file-name}.
	@code{file-name} need not exist.
	_EOF_;
};

flag = {
    name        = first_index;
	arg_type    = number;
    arg_default = 0;
    arg_name    = first-index;
    descrip     = "The first index to apply to groups";
	doc = <<-  _EOF_
	By default, the first occurrance of a named definition will have an
	index of zero.  Sometimes, that needs to be a reserved value.  Provide
	this option to specify a different starting point.
	_EOF_;
};

flag = {
    name      = input;
    arg_type  = string;
    arg_name  = file;
    max       = NOLIMIT;
    min       = 1;
    settable;
    stack_arg;
    default;
    descrip   = "Input file to search for defs";

    doc = <<-  _EOF_
	All files that are to be searched for definitions must be named on
	the command line or read from @code{stdin}.  If there is only one
	@code{input} option and it is the string, "-", then the input file
	list is read from @code{stdin}.  If a command line argument is not
	an option name and does not contain an assignment operator
	(@code{=}), then it defaults to being an input file name.
	At least one input file must be specified.
	_EOF_;
};

flag = {
    name      = subblock;
    arg_type  = string;
    arg_name  = sub-def;
    max       = NOLIMIT;
    stack_arg;
    descrip   = "subblock definition names";
    doc = <<- _EOF_
		This option is used to create shorthand entries for nested definitions.
		For example, with:
		@table @r
		@item using subblock thus
		@code{--subblock=arg=argname,type,null}
		@item and defining an @code{arg} thus
		@code{arg: this, char *}
		@item will then expand to:
		@code{arg = @{ argname = this; type = "char *"; @};}
		@end table
		The "this, char *" string is separated at the commas, with the
		white space removed.  You may use characters other than commas by
		starting the value string with a punctuation character other than
		a single or double quote character.  You may also omit intermediate
		values by placing the commas next to each other with no intervening
		white space.  For example, "+mumble++yes+" will expand to:
		@*
		@code{arg = @{ argname = mumble; null = "yes"; @};}.
		_EOF_;
};

flag = {
    name      = listattr;
    arg_type  = string;
    arg_name  = def;
    max       = NOLIMIT;
    stack_arg;
    descrip   = "attribute with list of values";
    doc = <<- _EOF_
		This option is used to create shorthand entries for definitions
		that generally appear several times.  That is, they tend to be
		a list of values.  For example, with:
		@*
		@code{listattr=foo} defined, the text:
		@*
		@code{foo: this, is, a, multi-list} will then expand to:
		@*
		@code{foo = 'this', 'is', 'a', 'multi-list';}
		@*
		The texts are separated by the commas, with the
		white space removed.  You may use characters other than commas by
		starting the value string with a punctuation character other than
		a single or double quote character.
		_EOF_;
};

flag = {
    name        = filelist;
    arg_type    = string;
    arg_optional;
    arg_name    = file;
    descrip     = "Insert source file names into defs";
    doc =
    "Inserts the name of each input file into the output definitions.\n"
    "If no argument is supplied, the format will be:\n"
    "@example\ninfile = '%s';\n@end example\n"
    "If an argument is supplied, that string will be used for the entry\n"
    "name instead of @var{infile}.";
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Definition Insertion Options:
 */
flag = {
    name        = doc_insert;
    descrip     = "Definition insertion options";
    documentation;
};

flag = {
    name        = assign;
    arg_type    = string;
    arg_name    = ag-def;
    max         = NOLIMIT;
    stack_arg;
    descrip     = "Global assignments";
    doc =
    "The argument to each copy of this option will be inserted into\n"
    "the output definitions, with only a semicolon attached.";
};

flag = {
    name        = common_assign;
    arg_type    = string;
    arg_name    = ag-def;
    max         = NOLIMIT;
    stack_arg;
    descrip     = "Assignments common to all blocks";
    doc =
    "The argument to each copy of this option will be inserted into\n"
    "each output definition, with only a semicolon attached.";
};

flag = {
    name        = copy;
    arg_type    = string;
    arg_name    = file;
    max         = NOLIMIT;
    stack_arg;
    descrip     = "File(s) to copy into definitions";
    doc =
    "The content of each file named by these options will be inserted into\n"
    "the output definitions.";
};

flag = {
    name        = srcfile;
    arg_type    = string;
    arg_optional;
    arg_name    = file;
    descrip     = "Insert source file name into each def";
    doc =
    "Inserts the name of the input file where a definition was found\n"
    "into the output definition.\n"
    "If no argument is supplied, the format will be:\n"
    "@example\nsrcfile = '%s';\n@end example\n"
    "If an argument is supplied, that string will be used for the entry\n"
    "name instead of @var{srcfile}.";
};

flag = {
    name        = linenum;
    arg_type    = string;
    arg_optional;
    arg_name    = def-name;
    descrip     = "Insert source line number into each def";
    doc =
    "Inserts the line number in the input file where a definition\n"
    "was found into the output definition.\n"
    "If no argument is supplied, the format will be:\n"
    "@example\nlinenum = '%s';\n@end example\n"
    "If an argument is supplied, that string will be used for the entry\n"
    "name instead of @var{linenum}.";
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Definition Output Disposition Options:
 */
flag = {
    name        = doc_output;
    descrip     = "Definition output disposition options:";
    documentation;
};

flag = {
    name        = output;
    equivalence = "autogen";
    arg_type    = string;
    arg_name    = file;
    descrip     = "Output file to open";
    doc =
    "If you are not sending the output to an AutoGen process,\n"
    "you may name an output file instead.";
};

flag = {
    name        = "autogen";
    equivalence = "autogen";
    arg_type    = string;
    arg_optional;
    arg_name    = ag-cmd;
    disable     = "no";
    enabled;
    descrip     = "Invoke AutoGen with defs";
    doc =
    "This is the default output mode.  Specifying @code{no-autogen} is\n"
    "equivalent to @code{output=-}.  If you supply an argument to this\n"
    "option, that program will be started as if it were AutoGen and\n"
    "its standard in will be set to the output definitions of this program.";
};

flag = {
    name        = template;
    arg_type    = string;
    arg_name    = file;
    descrip     = "Template Name";
    doc =
    "Specifies the template name to be used for generating the final output.";
};

flag = {
    name        = agarg;
    arg_type    = string;
    arg_name    = ag-opt;
    max         = NOLIMIT;
    stack_arg;
    descrip     = "AutoGen Argument";
    flags_cant  = output;
    doc =
    "This is a pass-through argument.  It allows you to specify any\n"
    "arbitrary argument to be passed to AutoGen.";
};

flag = {
    name        = base_name;
    arg_type    = string;
    arg_name    = name;
    descrip     = "Base name for output file(s)";
    flags_cant  = output;
    doc =
    "When output is going to AutoGen, a base name must either be supplied\n"
    "or derived.  If this option is not supplied, then it is taken from\n"
    "the @code{template} option.  If that is not provided either, then\n"
    "it is set to the base name of the current directory.";
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Program Documentation
 */

detail =
"This program extracts AutoGen definitions from a list of source files.
Definitions are delimited by `/*=<entry-type> <entry-name>\\n' and
`=*/\\n'.  From that, this program creates a definition of the
following form:\n
    #line nnn \"source-file-name\"
    entry_type = {
        name = entry_name;
        ...
    };\n
The ellipsis '...' is filled in by text found between the two
delimiters, with everything up through the first sequence of
asterisks deleted on every line.

There are two special ``entry types'':

*  The entry_type enclosure and the name entry will be omitted
   and the ellipsis will become top-level definitions.

-- The contents of the comment must be a single getdefs option.
   The option name must follow the double hyphen and its argument
   will be everything following the name.  This is intended for use
   with the ``subblock'' and ``listattr'' options.";


/* * * * * MAN PAGE DESCRIPTION * * * * * * * * * * * * * * * * * * * */

prog_man_descrip = <<- END_MAN_DESCRIP
	This program extracts \fBAutoGen\fP definitions from a list of source files.
	Definitions are delimited by "/*=<entry-type> <entry-name>\n" and "=*/\n".
	From that, this program creates a definition of the following form:

	    #line nnn "source-file-name"
	    entry_type = {
	        name = entry_name;
	        ...
	    };

	The ellipsis `...' is filled in by text found between the two delimiters, with
	everything up through the first sequence of asterisks deleted on every line.
	Additionally, if the `<entry-name>' is followed by a comma, the word `ifdef'
	(or 'ifndef') and a name `if_name', then the above entry will appear as:

	.nf
	.na
	    #ifdef if_name
	    #line nnn "source-file-name"
	    entry_type = {
	        name = entry_name;
	        ...
	    };
	    #endif

	There are two special ``entry types'':

	*   The entry_type enclosure and the name entry will be omitted
	    and the ellipsis will become top-level definitions.

	--  The contents of the comment must be a single getdefs option.
	    The option name must follow the double hyphen and its argument
	    will be everything following the name.  This is intended for use
	    with the @code{subblock} and @code{listattr} options.
	END_MAN_DESCRIP;

man_doc = '.SH "SEE ALSO"
This program is documented more fully in the Getdefs section
of the Add-On chapter in the
.IR AutoGen
Info system documentation.';


/* * * * * INFO DOC DESCRIPTION * * * * * * * * * * * * * * * * * * * */

prog_info_descrip = <<_EOF_
This program extracts AutoGen definitions from a list of source files.
Definitions are delimited by `/*=<entry-type> <entry-name>\n' and `=*/\n'.
From that, this program creates a definition of the following form:

@format
    #line nnn "source-file-name"
    entry_type = @{
        name = entry_name;
        ...
    @};
@end format

The ellipsis ``...'' is filled in by text found between the two delimiters,
using the following rules:

@enumerate
@item
Each entry is located by the pattern "\n[^*\n]*\\*[ \t]*([a-z][a-z0-9_]*):".
Fundamentally, it finds a line that, after the first asterisk on the line,
contains whitespace then a name and is immediately followed by a colon.
The name becomes the name of the attribute and what follows, up to the
next attribute, is its value.
@item
If the first character of the value is either a single or double quote,
then you are responsible for quoting the text as it gets inserted into
the output definitions.
@item
All the leading text on a line is stripped from the value.
The leading text is everything before the first asterisk,
the asterisk and all the whitespace characters that immediately
follow it.  If you want whitespace at the beginnings of the lines
of text, you must do something like this:

@example
 * mumble:
 * "  this is some\n"
 * "  indented text."
@end example

@item
If the `<entry-name>' is followed by a comma, the word `ifdef'
(or 'ifndef') and a name `if_name', then the above entry will appear as:

@example
#ifdef if_name
#line nnn "source-file-name"
entry_type = @{
    name = entry_name;
    ...
@};
#endif
@end example

@item
If you use of the @code{subblock} option, you can specify a nested
value, @xref{getdefs subblock}.  That is, this text:

@example
 * arg:  int, this, what-it-is
@end example

with the `--subblock=arg=type,name,doc' option would yield:

@example
arg = @{ type = int; name = this; doc = what-it-is; @};
@end example
@end enumerate
_EOF_;
